Pre-

docker 
docker version 
docker --version 
docker info 

Docker containers 

docker container run --publish 80:80 --detach --name webhost nginx 
docker container run --publish 8080:8080 --detach --name webhost2 nginx 

Stop/start
docker container ls - retrieve id of containers 

docker container stop $1 $2 etc

docker container prune to remove all containers 

docker rmi nginx 


What happens?
1. Looks for that image locally in image cache, doesn't find anything. 
2. Then looks in remote image repository (defaults to Docker hub). 
3. Downloads the latest version (nginx:latest by default).
4. Creates new container based on that image and prepares to start. 
5. Gives it a virtual IP on a private network inside docker engine.
6. Opens up port 80 on host and forwards to port 80 in container. 
7. Starts container by using the CMD in the image Dockerfile. 


- Docker containers are NOT vms. 
- Docker is a process.
docker container run --name mongo -d mongo 
# ps aux | grep mongo 
docker container stop 9ae 
# ps aux | grep mongo

- Its just a process using the same kernel as any other exec/program on your system. 

Documentation 
- docs.docker.com (excellent source of docker documentation)

Assignment: Manage Multiple Containers 
nginx, mysql, httpd
--detached (-d) 
--name
--publish 80:80 8080:80 3306:3306 

Pass envvars:
mysql use: --environment or -e  to pass in MYSQL_RANDOM_ROOT_PASSWORD=yes 
docker container logs 
docker container stop/start 

docker container run --publish 3306:3306 --name db01 --env MYSQL_RANDOM_ROOT_PASSWORD=true mysql 

docker inspect - discern specs and configurations
docker container stats - realtime monitoring of resources
docker container top - realtime monitoring of resources


Getting a shell inside of containers 
- docker container run -it (start new container interactively) 
- docker container exec -it (run additional command in existing container) 

docker container run -it --name ubuntu ubuntu 
When you run a container/image like this, when you exit the process will also exit.
To attach back to the container: 
docker container start -ai ubuntu  || exiting will exit the process again

Do you want to see the shell inside of a running container 
docker container exec -i -t mysql bash 
 
docker pull alpine 
docker container run -it alpine sh (bash will create and error) 

Docker Networking Concepts 
- Each container is connected to a private virtual network "bridge" 
- Each virtual network routes through NAT firewall on host IP
- All containers on a virtual network can talk to each other without -p 
- Best practice is to create a new virtual network for each app
	- network "my_web_app" for mysql and php/apache containers 
	- network "my_api" for mongo and nodejs containers 
- Batteries included, but removable" 
	- Defaults work well in many cases, but easy to swap out parts to customize further 
- Make new virtual networks based on Sec reqs 
- Attach containers to more than one virtual network (or none) 
- Skip virtual networks and use host IP (--net=host) 
- Use different Docker network drivers to gain new abilites 

docker container port webhost <or name of container>
docker container inspect --format '{{ .NetworkSettings.IPAddress }}' 

CLI
docker network ls - show networks 
docker network inspect <> - inspect a network 
docker network create --driver - create a network
docker network connect - attach a network to a container 
docker network disconnect - detach a network from a container

Ex: 
docker network inspect bridge 
# this will show what networks are connected and other useful information

docker network create my_app_net 
docker container run -d --name new_nginx --network my_app_net nginx 
docker network inspect my_app_net [look in container section] 

docker network --help 

Connect a new network to a old container
docker network connect my_app_net (old container) 
docker network disconnect my_app_net (old container) 

DNS 
--link on container run 

# use network-aliases
docker container run -d --name elas01 --network distros --net-alias search elasticsearch:2
docker container run -d --name elas02 --network distros --net-alias search elasticsearch:2
docker container ls
docker pull alpine
docker container ls
docker container ls -a
docker container --rm --net distros alpine nslookup search
docker container run --rm --net distros alpine nslookup search
docker container run --help
docker images
docker container ls

# obtain interloper
docker container run --rm --net distros centos curl -s search:9200

# Docker Images 
+ docker pull pulls down latest build by default 
+ you can download alpine versions as well - hub.docker.com (alpine is very very small foot prints)

FROM nginx:latest
WORKDIR /usr/share/nginx/html 
COPY index.html index.html # which copies the index.html that you constructed (1st) into the container (2nd)

docker image build -t nginx-with-html .
docker container run -p 80:80 --rm nginx-with-html
